/**
 * Created by liu on 17-2-1.
 */
"use strict";
const fs       = require('fs');
const shelljs  = require('shelljs');
const crypto   = require('crypto');
const uglifyjs = require('uglify-js');

const HEADER =
          '/*\n' +
          ' This file is generated by requirejs-builder, used for config of RequireJS. \n' +
          ' Please don\'t modify this file.\n' +
          ' */\n\n';

class RequireJSBuilder {
    constructor() {
        this.init({});
        this.nameArr   = {};
        this.appConfig = {};
        this.libConfig = {};
    }

    init(options) {
        this.options      = {
            root_dir      : options.root_dir || '',
            hash_method   : options.hash_method || 'md5',
            node_modules  : options.node_modules || 'node_modules',
            bower_modules : options.bower_modules || 'bower_modules',
            lib_output    : options.lib_output || 'js-dist',
            js_output_dir : options.lib_output || 'dist/js',
            css_output_dir: options.lib_output || 'dist/css'
        };
        this.remove_files = {};
        this.initDir(this.options.js_output_dir);
        this.initDir(this.options.css_output_dir);
    }

    initDir(dir) {
        this.mkdirMulti(dir);
        const files = fs.readdirSync(dir);
        for (let i = 0; i < files.length; i++) {
            let filePath = dir + '/' + files[i];
            const stats  = fs.statSync(filePath);
            if (!stats.isDirectory()) {
                this.remove_files[filePath] = true;
            }
        }
    }

    isUnique(name) {
        return !this.nameArr.hasOwnProperty(name);
    }

    addName(name) {
        if (!this.nameArr.hasOwnProperty(name)) {
            this.nameArr[name] = true;
            return true;
        }
        return false;
    }

    log(order, info) {
        for (let i = order.length; i < 8; i++) {
            order += ' ';
        }
        console.log(`${order} | ${info}`);
    }

    mkdirMulti(dir) {
        try {
            fs.accessSync(dir);
        } catch (err) {
            let index = dir.lastIndexOf('/');
            if (index > 0) {
                this.mkdirMulti(dir.substring(0, index));
            }
            if (index !== dir.length - 1) {
                fs.mkdirSync(dir);
            }
        }
    }

    addFile(name, inputDir, outputDir, fileName, fileNameOutput, deps, css) {
        if (this.addName(name)) {
            this.mkdirMulti(outputDir);
            let data                  = this.processJs(inputDir, outputDir, name, fileName, fileNameOutput);
            this.libConfig[data.name] = {
                js   : data.js,
                minjs: data.minjs,
                deps : deps,
                css  : css
            }
        }
    }

    addFileTraversal(inputDir, outputDir, prefix, relativeDir = '') {
        this.mkdirMulti(outputDir + relativeDir);
        const files = fs.readdirSync(inputDir + relativeDir);
        for (let i = 0; i < files.length; i++) {
            let file_dir = relativeDir + '/' + files[i];
            const stats  = fs.statSync(inputDir + file_dir);
            if (stats.isDirectory()) {
                this.addFileTraversal(inputDir, outputDir, prefix, file_dir);
            }
            else {
                let check_min_js = files[i].match(/\.min[\W\w]*\.js/);
                let check_js     = files[i].match(/\.js$/);
                if (!check_min_js && check_js) {
                    const fileName  = files[i].replace(/\.js$/, ''),
                          fileAlias = prefix + relativeDir.replace('/', '.') + '.' + fileName;
                    if (this.addName(fileAlias)) {
                        const data                = this.processJs(
                            inputDir + relativeDir,
                            outputDir + relativeDir,
                            fileAlias, fileName
                        );
                        this.appConfig[data.name] = {
                            js   : data.js,
                            minjs: data.minjs
                        }
                    }
                }
            }
        }
    }

    processJs(inputDir, outputDir, fileAlias, fileName, fileNameOutput = fileName) {
        const inputPath     = `${inputDir}/${fileName}.js`,
              buffer        = fs.readFileSync(inputPath) + fileAlias,
              hashcode      = crypto.createHash(this.options.hash_method).update(buffer).digest('hex'),
              signature     = hashcode.substring(0, 16),
              outputPath    = `${this.options.js_output_dir}/${signature}.js`,
              outputPathMin = `${this.options.js_output_dir}/${signature}.min.js`;
        // outputPath    = `${outputDir}/${fileNameOutput}.js`,
        // outputPathMin = `${outputDir}/${fileNameOutput}.min.${signature}.js`;
        this.log('Process', `${inputPath} (${signature}) ...`);
        try {
            fs.accessSync(outputPath);
            fs.accessSync(outputPathMin);
        } catch (err) {
            /*const reg = new RegExp(`${fileNameOutput}\\.min\\.(js|[\\W\\w]*\\.js)$`);
             let list  = shelljs.ls(`${outputDir}`);
             if (list.stdout) {
             list    = list.grep(reg);
             let cmd = list.stdout.replace(/(^\s*)|(\s*$)/g, '');
             if (cmd) {
             cmd = cmd.split('\n');
             for (let i = 0; i < cmd.length; i++) {
             cmd[i] = `${outputDir}/${cmd[i]}`;
             this.log('Remove', cmd[i]);
             }
             shelljs.rm(cmd);
             }
             }*/
            this.log('Generate', outputPath);
            fs.writeFileSync(outputPath, buffer);
            this.log('Generate', outputPathMin);
            fs.writeFileSync(outputPathMin, uglifyjs.minify(inputPath).code);
        }
        if (this.remove_files.hasOwnProperty(outputPath)) {
            delete this.remove_files[outputPath];
        }
        if (this.remove_files.hasOwnProperty(outputPathMin)) {
            delete this.remove_files[outputPathMin];
        }
        this.log('Status', 'Up to date');
        return {
            name : fileAlias,
            js   : outputPath,
            minjs: outputPathMin
        };
    }

    build(filePath) {

        for (let item in this.remove_files) {
            try {
                fs.unlinkSync(item);
                this.log('Remove', item);
            } catch (err) {
            }
        }

        const printArr = (arr) => {
            let str = '[';
            if (arr.length > 0) {
                for (let i = 0; i < arr.length - 1; i++) {
                    str += `'${arr[i]}', `;
                }
                str += `'${arr[arr.length - 1]}'`;
            }
            return str + ']';
        };

        const appFilePath = filePath + '.js';

        let fd = fs.openSync(appFilePath, 'w');
        fs.writeSync(fd, HEADER);

        fs.writeSync(fd, 'requirejs.config({\n\n');
        fs.writeSync(fd, '    baseUrl: \'\',\n\n');

        // Paths
        fs.writeSync(fd, '    paths: {\n\n');
        fs.writeSync(fd, '        // lib config\n');
        for (let item in this.libConfig) {
            fs.writeSync(fd, `        '${item}': '${this.libConfig[item].minjs}',\n`)
        }
        fs.writeSync(fd, '\n');
        fs.writeSync(fd, '        // app config\n');
        for (let item in this.appConfig) {
            fs.writeSync(fd, `        '${item}': '${this.appConfig[item].minjs}',\n`)
        }
        fs.writeSync(fd, '\n    },\n\n');

        // Shim
        fs.writeSync(fd, '    shim: {\n\n');
        for (let item in this.libConfig) {
            const config = this.libConfig[item];
            let deps     = [];
            for (let i = 0; i < config.deps.length; i++) {
                deps.push(config.deps[i]);
            }
            for (let cssFile in config.css) {
                deps.push(cssFile);
            }
            if (deps.length > 0) {
                fs.writeSync(fd, `        '${item}': ${printArr(deps)},\n`);
            }
        }

        fs.writeSync(fd, '\n    }\n\n');


        fs.writeSync(fd, '});\n\n');

        fs.closeSync(fd);
        //console.log(filePath);
    }
}

let builder = new RequireJSBuilder();

module.exports = {
    init: (options) => {
        builder.init(options);
    },

    addAppDir: (inputDir, outputDir, prefix) => {
        builder.addFileTraversal(inputDir, outputDir, prefix);
    },

    addFile: (name, file, deps = [], css = []) => {

    },

    addNode: (name, file, deps = [], css = []) => {
        const index    = file.lastIndexOf('/'),
              fileDir  = index > 0 ? file.substring(0, index) : '',
              fileName = index > 0 ? file.substring(index + 1) : file;
        builder.addFile(
            name, builder.options.node_modules + '/' + fileDir,
            builder.options.lib_output + '/' + builder.options.node_modules,
            fileName, name,
            deps, css);
    },

    addBower: (name, file, deps = [], css = []) => {
        const index    = file.lastIndexOf('/'),
              fileDir  = index > 0 ? file.substring(0, index) : '',
              fileName = index > 0 ? file.substring(index + 1) : file;
        builder.addFile(
            name, builder.options.bower_modules + '/' + fileDir,
            builder.options.lib_output + '/' + builder.options.bower_modules,
            fileName, name,
            deps, css);
    },

    build: (filePath) => {
        builder.build(filePath);
    }
};

