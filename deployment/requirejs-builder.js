/**
 * Created by liu on 17-2-1.
 */
"use strict";
const fs       = require('fs');
const shelljs  = require('shelljs');
const crypto   = require('crypto');
const uglifyjs = require('uglify-js');

const HEADER =
          '/*\n' +
          ' This file is generated by requirejs-builder, used for config of RequireJS. \n' +
          ' Please don\'t modify this file.\n' +
          ' */\n\n';

class RequireJSBuilder {
    constructor(options) {
        this.options   = {
            root_dir     : options.root_dir || '',
            node_modules : options.node_modules || 'node_modules',
            bower_modules: options.bower_modules || 'bower_modules'
        };
        this.nameArr   = {}
        this.appConfig = {};
        this.libConfig = {};
    }

    isUnique(name) {
        return !this.nameArr.hasOwnProperty(name);
    }

    addName(name) {
        this.nameArr[name] = true;
    }

    log(order, info) {
        for (let i = order.length; i < 8; i++) {
            order += ' ';
        }
        console.log(`${order} | ${info}`);
    }

    static mkdirMulti(dir) {
        try {
            fs.accessSync(dir);
        } catch (err) {
            let index = dir.lastIndexOf('/');
            if (index > 0) {
                RequireJSBuilder.mkdirMulti(dir.substring(0, index));
            }
            if (index !== dir.length - 1) {
                fs.mkdirSync(dir);
            }
        }
    }

    addAppDir(inputDir, outputDir, prefix) {
        let traversal = (relativeDir) => {
            RequireJSBuilder.mkdirMulti(outputDir + relativeDir);
            const files = fs.readdirSync(inputDir + relativeDir);
            for (let i = 0; i < files.length; i++) {
                let file_dir = relativeDir + '/' + files[i];
                const stats  = fs.statSync(inputDir + file_dir);
                if (stats.isDirectory()) {
                    traversal(file_dir);
                }
                else {
                    let check_min_js = files[i].match(/\.min[\W\w]*\.js/);
                    let check_js     = files[i].match(/\.js$/);
                    if (!check_min_js && check_js) {
                        let fileName = files[i].replace(/\.js$/, '');
                        this.processJs(inputDir, outputDir, relativeDir, fileName, prefix);
                    }
                }
            }
        };
        traversal('');
        return this;
    }

    addFile(name, file, deps = [], css = {}) {
        if (this.isUnique(name)) {
            this.addName(name);
            this.libConfig[name] = {
                js   : file,
                minjs: file + '.min',
                deps : deps,
                css  : css
            }
        }
        return this;
    }

    addNode(name, file, deps = [], css = {}) {
        return this.addFile(name, this.options.node_modules + '/' + file, deps, css);
    }

    addBower(name, file, deps = [], css = {}) {
        return this.addFile(name, this.options.bower_modules + '/' + file, deps, css);
    }

    processJs(inputDir, outputDir, relativeDir, fileName, prefix) {
        const inputPath = `${inputDir}${relativeDir}/${fileName}.js`,
              buffer    = fs.readFileSync(inputPath),
              fileAlias = prefix + relativeDir.replace('/', '.') + '.' + fileName;
        let hash        = crypto.createHash('sha1');
        hash.update(buffer);
        const signature     = hash.digest('hex').substring(0, 6),
              outputPath    = `${outputDir}${relativeDir}/${fileName}.js`,
              outputPathMin = `${outputDir}${relativeDir}/${fileName}.min.${signature}.js`;
        this.log('Process', `${inputPath} (${signature}) ...`);
        try {
            fs.accessSync(outputPath);
            fs.accessSync(outputPathMin);
        } catch (err) {
            const reg = new RegExp(`${fileName}\\.min\\.(js|[\\W\\w]*\\.js)$`);
            let list  = shelljs.ls(`${outputDir}${relativeDir}`);
            if (list.stdout) {
                list    = list.grep(reg);
                let cmd = list.stdout.replace(/(^\s*)|(\s*$)/g, '');
                if (cmd) {
                    cmd = cmd.split('\n');
                    for (let i = 0; i < cmd.length; i++) {
                        cmd[i] = `${outputDir}${relativeDir}/${cmd[i]}`;
                        this.log('Remove', cmd[i]);
                    }
                    shelljs.rm(cmd);
                }
            }
            this.log('Generate', outputPath);
            fs.writeFileSync(outputPath, buffer);
            this.log('Generate', outputPathMin);
            fs.writeFileSync(outputPathMin, uglifyjs.minify(inputPath).code);
        }
        if (this.isUnique(fileAlias)) {
            this.addName(fileAlias);
            this.appConfig[fileAlias] = {
                js   : outputPath,
                minjs: outputPathMin
            }
        }
        this.log('Status', 'Up to date');
    }

    build(filePath) {
        const printArr = (arr) => {
            let str = '[';
            if (arr.length > 0) {
                for (let i = 0; i < arr.length - 1; i++) {
                    str += `'${arr[i]}', `;
                }
                str += `'${arr[arr.length - 1]}'`;
            }
            return str + ']';
        };

        const appFilePath = filePath + '.js';

        let fd = fs.openSync(appFilePath, 'w');
        fs.writeSync(fd, HEADER);

        fs.writeSync(fd, 'requirejs.config({\n\n');
        fs.writeSync(fd, '    baseUrl: \'\',\n\n');

        // Paths
        fs.writeSync(fd, '    paths: {\n\n');
        fs.writeSync(fd, '        // lib config\n');
        for (let item in this.libConfig) {
            fs.writeSync(fd, `        '${item}': '${this.libConfig[item].minjs}',\n`)
        }
        fs.writeSync(fd, '\n');
        fs.writeSync(fd, '        // app config\n');
        for (let item in this.appConfig) {
            fs.writeSync(fd, `        '${item}': '${this.appConfig[item].minjs}',\n`)
        }
        fs.writeSync(fd, '\n    },\n\n');

        // Shim
        fs.writeSync(fd, '    shim: {\n\n');
        for (let item in this.libConfig) {
            const config = this.libConfig[item];
            let deps     = [];
            for (let i = 0; i < config.deps.length; i++) {
                deps.push(config.deps[i]);
            }
            for (let cssFile in config.css) {
                deps.push(cssFile);
            }
            if (deps.length > 0) {
                fs.writeSync(fd, `        '${item}': ${printArr(deps)},\n`);
            }
        }

        fs.writeSync(fd, '\n    }\n\n');


        fs.writeSync(fd, '});\n\n');

        fs.closeSync(fd);

        //console.log(filePath);
    }
}

module.exports = {
    initBuilder: (options) => {
        return new RequireJSBuilder(options);
    }
};

